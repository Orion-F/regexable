{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Regexable Documentation Welcome to the official documentation for Regexable - a Python package designed to simplify the creation and management of regular expressions. Regexable provides an intuitive, readable, and chainable interface that makes working with regex easier for both beginners and experienced developers. Features Chainable Methods : Construct regex patterns step by step using a clean, chainable syntax. Anchors and Boundaries : Easily add start-of-line, end-of-line, word boundary, and other anchors to your patterns. Text Matching : Add specific text or optional text segments, and define characters to match or exclude. Quantifiers : Specify how many times a character or group should be matched (e.g., zero or more, one or more, exactly n times). Modifiers : Apply flags for case-insensitive or multiline matching. Grouping and Alternation : Group patterns together or create alternatives using the group and or_ methods. Utilities : Match, search, and compile patterns into regex objects. Quick Start Here\u2019s a quick example to get you started with Regexable: from regexable import Regexable # Construct a regex pattern pattern = Regexable()\\ .start_of_line()\\ .then(\"Hello\")\\ .whitespace()\\ .one_or_more()\\ .then(\"World\")\\ .end_of_line()\\ .build() # Match a string match = pattern.match(\"Hello World\") print(match) # Output: <re.Match object; span=(0, 11), match='Hello World'> # Check if a string matches the pattern if pattern.match(\"Hello World\"): print(\"Match found!\") Installation Install Regexable via pip: pip install regexable Contributing We welcome contributions! If you find a bug or have a feature request, please create an issue on our GitHub repository . License Regexable is licensed under the MIT License.","title":"Home"},{"location":"#regexable-documentation","text":"Welcome to the official documentation for Regexable - a Python package designed to simplify the creation and management of regular expressions. Regexable provides an intuitive, readable, and chainable interface that makes working with regex easier for both beginners and experienced developers.","title":"Regexable Documentation"},{"location":"#features","text":"Chainable Methods : Construct regex patterns step by step using a clean, chainable syntax. Anchors and Boundaries : Easily add start-of-line, end-of-line, word boundary, and other anchors to your patterns. Text Matching : Add specific text or optional text segments, and define characters to match or exclude. Quantifiers : Specify how many times a character or group should be matched (e.g., zero or more, one or more, exactly n times). Modifiers : Apply flags for case-insensitive or multiline matching. Grouping and Alternation : Group patterns together or create alternatives using the group and or_ methods. Utilities : Match, search, and compile patterns into regex objects.","title":"Features"},{"location":"#quick-start","text":"Here\u2019s a quick example to get you started with Regexable: from regexable import Regexable # Construct a regex pattern pattern = Regexable()\\ .start_of_line()\\ .then(\"Hello\")\\ .whitespace()\\ .one_or_more()\\ .then(\"World\")\\ .end_of_line()\\ .build() # Match a string match = pattern.match(\"Hello World\") print(match) # Output: <re.Match object; span=(0, 11), match='Hello World'> # Check if a string matches the pattern if pattern.match(\"Hello World\"): print(\"Match found!\")","title":"Quick Start"},{"location":"#installation","text":"Install Regexable via pip: pip install regexable","title":"Installation"},{"location":"#contributing","text":"We welcome contributions! If you find a bug or have a feature request, please create an issue on our GitHub repository .","title":"Contributing"},{"location":"#license","text":"Regexable is licensed under the MIT License.","title":"License"},{"location":"api_reference/","text":"API Reference Regexable Class Methods start_of_line() : Appends the start-of-line anchor ^ to the pattern. end_of_line() : Appends the end-of-line anchor $ to the pattern. then(text) : Appends the given text to the pattern, escaping any special characters. maybe(text) : Appends an optional occurrence of the given text to the pattern. anything() : Appends a wildcard pattern that matches any character zero or more times ( .* ). anything_but(text) : Appends a pattern that matches any character except the specified text one or more times. something() : Appends a wildcard pattern that matches any character one or more times ( .+ ). something_but(text) : Appends a pattern that matches any character except the specified text one or more times. digit() : Appends a pattern that matches any digit ( \\d ). whitespace() : Appends a pattern that matches any whitespace character ( \\s ). tab() : Appends a pattern that matches a tab character ( \\t ). newline() : Appends a pattern that matches a newline character ( \\n ). word() : Appends a pattern that matches any word character ( \\w ). ignore_case() : Appends a flag to the pattern to ignore case sensitivity ( (?i) ). multiline() : Appends a flag to the pattern to treat the target as multiline ( (?m) ). word_boundary() : Appends a pattern that matches a word boundary ( \\b ). not_word_boundary() : Appends a pattern that matches a non-word boundary ( \\B ). zero_or_more() : Appends a quantifier that matches the preceding element zero or more times ( * ). one_or_more() : Appends a quantifier that matches the preceding element one or more times ( + ). exactly(n) : Appends a quantifier that matches the preceding element exactly n times ( {n} ). at_least(n) : Appends a quantifier that matches the preceding element at least n times ( {n,} ). between(m, n) : Appends a quantifier that matches the preceding element between m and n times ( {m,n} ). group(pattern) : Appends a group pattern to the current pattern. or_(pattern) : Appends an alternative pattern (OR) to the current pattern. range(char1, char2) : Appends a character range pattern to the current pattern. build() : Compiles the current pattern into a regular expression object. match(text) : Attempts to match the compiled pattern against the given text. Each method returns an instance of Regexable , allowing method chaining. Examples See Examples for more detailed examples.","title":"API Reference"},{"location":"api_reference/#api-reference","text":"","title":"API Reference"},{"location":"api_reference/#regexable-class","text":"","title":"Regexable Class"},{"location":"api_reference/#methods","text":"start_of_line() : Appends the start-of-line anchor ^ to the pattern. end_of_line() : Appends the end-of-line anchor $ to the pattern. then(text) : Appends the given text to the pattern, escaping any special characters. maybe(text) : Appends an optional occurrence of the given text to the pattern. anything() : Appends a wildcard pattern that matches any character zero or more times ( .* ). anything_but(text) : Appends a pattern that matches any character except the specified text one or more times. something() : Appends a wildcard pattern that matches any character one or more times ( .+ ). something_but(text) : Appends a pattern that matches any character except the specified text one or more times. digit() : Appends a pattern that matches any digit ( \\d ). whitespace() : Appends a pattern that matches any whitespace character ( \\s ). tab() : Appends a pattern that matches a tab character ( \\t ). newline() : Appends a pattern that matches a newline character ( \\n ). word() : Appends a pattern that matches any word character ( \\w ). ignore_case() : Appends a flag to the pattern to ignore case sensitivity ( (?i) ). multiline() : Appends a flag to the pattern to treat the target as multiline ( (?m) ). word_boundary() : Appends a pattern that matches a word boundary ( \\b ). not_word_boundary() : Appends a pattern that matches a non-word boundary ( \\B ). zero_or_more() : Appends a quantifier that matches the preceding element zero or more times ( * ). one_or_more() : Appends a quantifier that matches the preceding element one or more times ( + ). exactly(n) : Appends a quantifier that matches the preceding element exactly n times ( {n} ). at_least(n) : Appends a quantifier that matches the preceding element at least n times ( {n,} ). between(m, n) : Appends a quantifier that matches the preceding element between m and n times ( {m,n} ). group(pattern) : Appends a group pattern to the current pattern. or_(pattern) : Appends an alternative pattern (OR) to the current pattern. range(char1, char2) : Appends a character range pattern to the current pattern. build() : Compiles the current pattern into a regular expression object. match(text) : Attempts to match the compiled pattern against the given text. Each method returns an instance of Regexable , allowing method chaining.","title":"Methods"},{"location":"api_reference/#examples","text":"See Examples for more detailed examples.","title":"Examples"},{"location":"examples/","text":"Examples Basic Example Here's a simple example demonstrating how to use Regexable to create and match a regex pattern: from regexable import Regexable pattern = Regexable()\\ .start_of_line()\\ .then(\"Hello\")\\ .whitespace()\\ .then(\"World\")\\ .end_of_line()\\ .build() text = \"Hello World\" match = pattern.match(text) if match: print(f\"Matched: {match.group(0)}\") # Output: Matched: Hello World else: print(\"No match found\") Common Patterns Matching an Email Address email_pattern = Regexable()\\ .start_of_line()\\ .word()\\ .then(\"@\")\\ .word()\\ .then(\".\")\\ .word()\\ .end_of_line()\\ .build() email = \"example@example.com\" match = email_pattern.match(email) if match: print(f\"Valid email: {match.group(0)}\") else: print(\"Invalid email\") This is much more readable and intuitive compared to writing the equivalent regex pattern directly: import re email_pattern = r\"^\\w+@\\w+\\.\\w+$\" email = \" match = re.match(email_pattern, email) if match: print(f\"Valid email: {match.group(0)}\") else: print(\"Invalid email\") Matching a Phone Number phone_pattern = Regexable()\\ .start_of_line()\\ .digit().exactly(3)\\ .then(\"-\")\\ .digit().exactly(3)\\ .then(\"-\")\\ .digit().exactly(4)\\ .end_of_line()\\ .build() phone = \"123-456-7890\" match = phone_pattern.match(phone) if match: print(f\"Valid phone number: {match.group(0)}\") else: print(\"Invalid phone number\") Using Modifiers Case Insensitive Matching case_insensitive_pattern = Regexable()\\ .ignore_case()\\ .then(\"hello\")\\ .build() text = \"Hello\" match = case_insensitive_pattern.match(text) if match: print(\"Case insensitive match found!\") Multiline Matching multiline_pattern = Regexable()\\ .multiline()\\ .start_of_line()\\ .then(\"Start\")\\ .build() text = \"Start\\nAnother line\" matches = multiline_pattern.search(text) if matches: print(\"Multiline match found!\") Explore more advanced usage in the API Reference .","title":"Examples"},{"location":"examples/#examples","text":"","title":"Examples"},{"location":"examples/#basic-example","text":"Here's a simple example demonstrating how to use Regexable to create and match a regex pattern: from regexable import Regexable pattern = Regexable()\\ .start_of_line()\\ .then(\"Hello\")\\ .whitespace()\\ .then(\"World\")\\ .end_of_line()\\ .build() text = \"Hello World\" match = pattern.match(text) if match: print(f\"Matched: {match.group(0)}\") # Output: Matched: Hello World else: print(\"No match found\")","title":"Basic Example"},{"location":"examples/#common-patterns","text":"","title":"Common Patterns"},{"location":"examples/#matching-an-email-address","text":"email_pattern = Regexable()\\ .start_of_line()\\ .word()\\ .then(\"@\")\\ .word()\\ .then(\".\")\\ .word()\\ .end_of_line()\\ .build() email = \"example@example.com\" match = email_pattern.match(email) if match: print(f\"Valid email: {match.group(0)}\") else: print(\"Invalid email\") This is much more readable and intuitive compared to writing the equivalent regex pattern directly: import re email_pattern = r\"^\\w+@\\w+\\.\\w+$\" email = \" match = re.match(email_pattern, email) if match: print(f\"Valid email: {match.group(0)}\") else: print(\"Invalid email\")","title":"Matching an Email Address"},{"location":"examples/#matching-a-phone-number","text":"phone_pattern = Regexable()\\ .start_of_line()\\ .digit().exactly(3)\\ .then(\"-\")\\ .digit().exactly(3)\\ .then(\"-\")\\ .digit().exactly(4)\\ .end_of_line()\\ .build() phone = \"123-456-7890\" match = phone_pattern.match(phone) if match: print(f\"Valid phone number: {match.group(0)}\") else: print(\"Invalid phone number\")","title":"Matching a Phone Number"},{"location":"examples/#using-modifiers","text":"","title":"Using Modifiers"},{"location":"examples/#case-insensitive-matching","text":"case_insensitive_pattern = Regexable()\\ .ignore_case()\\ .then(\"hello\")\\ .build() text = \"Hello\" match = case_insensitive_pattern.match(text) if match: print(\"Case insensitive match found!\")","title":"Case Insensitive Matching"},{"location":"examples/#multiline-matching","text":"multiline_pattern = Regexable()\\ .multiline()\\ .start_of_line()\\ .then(\"Start\")\\ .build() text = \"Start\\nAnother line\" matches = multiline_pattern.search(text) if matches: print(\"Multiline match found!\") Explore more advanced usage in the API Reference .","title":"Multiline Matching"},{"location":"installation/","text":"Installation Prerequisites Before installing Regexable, ensure you have Python 3.6 or higher installed on your system. You can check your Python version by running: python --version Installing Regexable You can install Regexable using pip, the Python package manager. Run the following command in your terminal: pip install regexable This command will download and install Regexable and its dependencies. Verifying the Installation To verify that Regexable was installed correctly, you can try importing it in a Python shell: >>> from regexable import Regexable >>> regex = Regexable() >>> print(regex) <regexable.core.Regexable object at 0x...> If no errors are thrown, then you have successfully installed Regexable. Upgrading Regexable To upgrade to the latest version of Regexable, use the following pip command: pip install --upgrade regexable Uninstalling Regexable If you need to uninstall Regexable, you can do so with pip: pip uninstall regexable","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#prerequisites","text":"Before installing Regexable, ensure you have Python 3.6 or higher installed on your system. You can check your Python version by running: python --version","title":"Prerequisites"},{"location":"installation/#installing-regexable","text":"You can install Regexable using pip, the Python package manager. Run the following command in your terminal: pip install regexable This command will download and install Regexable and its dependencies.","title":"Installing Regexable"},{"location":"installation/#verifying-the-installation","text":"To verify that Regexable was installed correctly, you can try importing it in a Python shell: >>> from regexable import Regexable >>> regex = Regexable() >>> print(regex) <regexable.core.Regexable object at 0x...> If no errors are thrown, then you have successfully installed Regexable.","title":"Verifying the Installation"},{"location":"installation/#upgrading-regexable","text":"To upgrade to the latest version of Regexable, use the following pip command: pip install --upgrade regexable","title":"Upgrading Regexable"},{"location":"installation/#uninstalling-regexable","text":"If you need to uninstall Regexable, you can do so with pip: pip uninstall regexable","title":"Uninstalling Regexable"}]}